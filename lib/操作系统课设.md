# 操作系统课设



## 实验课题

​	基于缓冲技术的消息通道发送接收命令的模拟实现，同时模拟单CPU的情况下进行调度和进程运行。



## 实验分析

### 一、单CPU处理的问题

​	我们认为一共有三个行为，分别是CPU调度、发送者发送消息、接收者接收消息。而我们模拟单CPU运行，也就是在同一时间在我们模拟的操作系统中，应当只有三者之一在运行。为了实现这个模拟，我们定义一个`mutex CPU=1`来保证三种行为的互斥。

​	而要保证我们的程序一定是掌握`CPU`变量的进程在执行的，我们只需要保证所有的发送和接收的方法，要想获取CPU执行，必须通过CPU调度来获得CPU。为此，~~我们为系统设计了两个队列，分别是就绪队列和紧急等待队列。紧急等待队列是那些接收进程，因为没有获取到完整信息或者消息队列为空而进入等待对应资源的接收进程。~~

​	(问题：如果有多个进程都等待不同的资源，这个时候一个发送者发送了消息，使某些接收进程可以继续执行，如果正常情况下可以直接使用`V(receive)`，但如果模拟单CPU的话，我们如何在CPU中的紧急等待队列中得知哪些进程可以执行？目前思路：添加第三个队列为紧急就绪队列，发送者发送消息以后唤醒等待者，然后等待者不直接执行而是进入紧急等待队列，然后CPU调度的时候优先看紧急就绪队列，若没有则看就绪队列。紧急等待队列只用于发送者唤醒(也就是说，这只是一个逻辑上的概念，实际上在系统类中应该没有这个紧急等待队列))

​	所以我们应该是三个队列，分别是1.保存还没有运行的接收者和发送者的就绪队列。2.紧急等待队列，这个是虚拟的，并不会显式地保存在系统类中，因为调用了`receive()`但是没有获取完整信息的进程将会等待。3.紧急就绪队列，当紧急等待的进程因为有发送者发消息而被唤醒的时候，他会进入系统类的紧急就绪队列，之后将优先于普通就绪进程执行。	

### 二、普通的消息发送获取

​	按照课件所写的步骤：

+ 创建缓冲区
+ 发送者申请缓冲区块，写入头信息和消息（这些都应该是调用我们的操作系统类的方法来实现）
+ 发送到接收者的消息链表中。

### 三、大消息的发送获取

​	 有可能会出现发送者要发送的消息过大，一个缓冲块并不能完整地存储所有的信息，即一个信息需要多个缓冲区块来传递，这种情况下，发送方不会太麻烦，只不过是额外进行消息切割为几个缓冲区块。问题主要在接收者方，接收者在接收时不一定能直接获得一个完整的信息，这个情况下会出现比较难以解决的问题有：

+ 可能会出现多个发送者对同一个接收者发送消息的问题，这时候接收者接收消息以后应该可以按照发送者分类。解决方法：使用map来记录不同发送者对应的队列。
+ 何时和如何判断是否接受到完整消息。
  - 首先说明何时接收：任意时刻都可以接收，但是如果没有接收到完整的信息，就进入~~紧急等待队列~~，直到有发送者唤醒，进入紧急就绪队列，等待CPU的调度。
  - 判断是否接收到完整的消息：每个消息块都会包含对应的消息发送者、消息总量以及当前消息编号，便利map中的所有发送者，看是否有发送完全的数据。

## 实验设计

### 一、信号量的处理

设计`semaphore`类，其包含信号量、PV操作。

### 二、发送者的设计

```java
public class sender{
	send(msg,receive_id){
        进入系统类的就绪队列;
        P(self);//自己等待CPU的调度
        发送者只调用系统的发送接口。
    }
}
```



### 三、接收者的设计



```java
public class receiver{
	Map<pid,msg_block> map_block;//用来存储发送者发送的非完整消息
    List<msg_block> linkmsg = LinkList<> //使用链表来模拟未读取的消息队列
    Boolean judge_complete(){
        用来检测我们的map中是否有完整的消息。
    }
    receive(){
        进入系统类的就绪队列;
        P(self);//自己等待CPU的调度
        
        while(有完整信息){
            //读取消息队列的消息
        	while(linkmsg != null){
                // 读取所有的消息队列
            	receive_block()
            }	
    		if 有完整消息
                释放缓冲区;
                返回完整消息
            else
                V(CPU) //释放CPU资源
                P(self) // 将自己放入紧急等待队列(虚拟的)
                放入系统类的紧急就绪队列
                P(self) //放到紧急就绪队列
        }
    }
}
```



### 四、系统类的设计

```java
public class System{
    semaphore CPU = 0;//CPU
    ready_queue;//就绪队列
    urgent_ready_queue; //紧急就绪队列
    
    send(){
        操作系统的发送消息;
       	将消息分块;
        多次send_block();//传递消息
        //若执行完毕，则释放CPU
        V(CPU)
    }
    
    send_block(){
        申请缓冲块;
        填写头部等信息;
        添加数据;
        发送到对应接收者的消息队列;
    }
    
    dispatch(){
        while(true){
        	//按照CPU调度算法选取不同的进程
            if 紧急就绪队列 不为空：
            	选取紧急就绪队列其中之一
        	else if 就绪队列不为空：
            	选取就绪队列其中之一
        	else:
        		continue;   
        	
            V(选取的进程);//让选取的进程执行
           	P(CPU);//表示CPU被进程占用
        }
            
    }
}
```



### 消息块的设计

我觉得方便起见的话，直接就缓冲区块也直接用这个？

```java
public class msg_block{
	int pid; //发送者id
    int msg_total; //共有多少个消息
    int msg_number;//当前消息编号
    int size;//本消息可用信息大小
    bytes[512] msg;//消息
}
```

